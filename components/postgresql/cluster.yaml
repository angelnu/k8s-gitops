---
apiVersion: postgresql.cnpg.io/v1
kind: Cluster
metadata:
  name: &ClusterName "${MY_APP}-db"
  annotations:
    cnpg.io/skipEmptyWalArchiveCheck: enabled # Allow for backup source and target to be the same
spec:
  instances: 3 # 1 Primary + 2 Replicas for High Availability

  # This tells CNPG how to behave during a node drain
  nodeMaintenanceWindow:
    inProgress: true
    reusePVC: true

  minSyncReplicas: 1
  maxSyncReplicas: 2

  affinity:
    # "required" ensures pods NEVER share a node
    podAntiAffinityType: required
    # Use "kubernetes.io/hostname" to target individual worker nodes
    topologyKey: kubernetes.io/hostname

  imageName: ghcr.io/cloudnative-pg/postgresql:17.1

  # 1. Continuous Backup to Synology (MinIO)
  plugins:
    - name: barman-cloud.cloudnative-pg.io
      isWALArchiver: true
      parameters:
        barmanObjectName: cluster-nas-backup

  # 2. Resource Management (Guaranteed QoS)
  # Keeping requests and limits identical prevents OOM kills
  resources:
    requests:
      memory: "192Mi"
      cpu: "20m"
    limits:
      memory: "1Gi"
      cpu: "1"

  # 3. Storage Configuration
  storage:
    storageClass: longhorn-postgres-replica-storage
    size: ${POSTGRES_STORAGE_SIZE}
  walStorage:
    # Separate WAL storage is recommended for production to avoid IO contention
    storageClass: longhorn-postgres-replica-storage
    size: ${POSTGRES_WALSTORAGE_SIZE}

  externalClusters:
    - name: source
      plugin:
        name: barman-cloud.cloudnative-pg.io
        parameters:
          barmanObjectName: cluster-nas-backup
          serverName: *ClusterName

  backup:
    target: prefer-standby # instead of primary
  
  # 4. Database Initialization
  bootstrap:
    recovery:
      source: source
      database: app
      secret:
        name: ${POSTGRES_RECOVERY_SECRETNAME}
    # initdb:
    #   database: app
